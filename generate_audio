import os
import time
import requests
import pandas as pd
import re
import unicodedata
import string
from tkinter import Tk, filedialog, messagebox

# ===== API Key é…ç½®ï¼ˆå†™æ­»åœ¨ä»£ç é‡Œï¼‰=====
API_KEY = "sk_255df5eece0e6606be8a93541da4e54f40decfd7abc0997f"  # â† è¿™é‡Œæ¢æˆä½ çš„çœŸå® Key
HEADERS = {
    "accept": "*/*",
    "xi-api-key": API_KEY,
    "Content-Type": "application/json"
}

MODEL_ID = "eleven_monolingual_v1"
VOICE_SETTINGS = {"stability": 0.5, "similarity_boost": 0.75}

# ===== æ¸…æ´—å‡½æ•° =====
def clean_text(text: str) -> str:
    text = re.sub(r"[\x00-\x1f\x7f-\x9f]", "", str(text))
    text = ''.join(c for c in text if c <= '\uFFFF')
    return text.strip()

def voice_id_cleaner(raw_id: str) -> str:
    raw_id = unicodedata.normalize("NFKC", str(raw_id))
    return ''.join(c for c in raw_id if c in string.ascii_letters + string.digits + "-_").strip()

def safe_filename(name: str) -> str:
    name = unicodedata.normalize("NFKD", str(name))
    out = ''.join(c for c in name if c in string.ascii_letters + string.digits + "_-")
    return out.strip() or "untitled"

# ===== è‡ªåŠ¨è¯»å–æ–‡ä»¶å†…å®¹ =====
def read_table_auto(file_path: str) -> pd.DataFrame | None:
    try:
        if file_path.endswith(".csv"):
            try:
                return pd.read_csv(file_path, encoding="utf-8", dtype=str)
            except UnicodeDecodeError:
                return pd.read_csv(file_path, encoding="gbk", dtype=str)
        elif file_path.endswith((".xls", ".xlsx")):
            return pd.read_excel(file_path, dtype=str)
        else:
            return None
    except Exception as e:
        print(f"âŒ æ— æ³•è¯»å– {file_path}ï¼Œé”™è¯¯: {e}")
        return None

# ===== ä»ä¸€è¡Œä¸­æŠ½å–å­—æ®µï¼ˆè‡ªé€‚é…åˆ—åæˆ–åˆ—ä½ï¼‰=====
def extract_fields(row: pd.Series, df: pd.DataFrame):
    def find_col(candidates):
        colmap = {str(c).strip().lower(): c for c in df.columns}
        for cand in candidates:
            key = cand.strip().lower()
            if key in colmap:
                return colmap[key]
        return None

    text_col = find_col(["text", "content", "æ–‡æœ¬", "å°è¯", "æœ—è¯»æ–‡æœ¬"])
    voice_col = find_col(["voice_id", "voice", "éŸ³è‰²", "å£°éŸ³", "è¯­éŸ³id"])
    id_col = find_col(["id", "row_id", "ç¼–å·", "åºå·"])

    text = (row[text_col] if text_col else (row.iloc[2] if len(row) > 2 else None))
    voice_id = (row[voice_col] if voice_col else (row.iloc[3] if len(row) > 3 else None))
    row_id = (row[id_col] if id_col else (row.iloc[1] if len(row) > 1 else None))
    return text, voice_id, row_id

# ===== è°ƒç”¨ ElevenLabs API åˆæˆè¯­éŸ³ =====
def generate_speech(text: str, voice_id: str, output_path: str):
    text = clean_text(text)
    voice_id = voice_id_cleaner(voice_id)
    api_url = f"https://api.elevenlabs.io/v1/text-to-speech/{voice_id}/stream"

    data = {"text": text, "model_id": MODEL_ID, "voice_settings": VOICE_SETTINGS}

    try:
        resp = requests.post(api_url, headers=HEADERS, json=data, timeout=60)
        if resp.status_code == 200 and resp.content:
            with open(output_path, "wb") as f:
                f.write(resp.content)
            print(f"âœ… æˆåŠŸç”Ÿæˆ: {output_path}")
            return True
        else:
            print(f"âŒ APIå¤±è´¥: {resp.status_code} - {resp.text[:200]}")
    except Exception as e:
        print(f"âŒ è¯·æ±‚å¼‚å¸¸: {e}")
    return False

# ===== å¤„ç†å•ä¸ªæ–‡ä»¶ =====
def process_file(file_path: str, base_output_dir: str):
    filename_raw = os.path.splitext(os.path.basename(file_path))[0]
    filename = safe_filename(filename_raw)
    df = read_table_auto(file_path)

    if df is None or df.empty:
        print(f"âš ï¸ æ–‡ä»¶ {file_path} æ— å†…å®¹ï¼Œè·³è¿‡")
        return

    file_output_dir = os.path.join(base_output_dir, filename)
    os.makedirs(file_output_dir, exist_ok=True)

    print(f"â–¶ï¸ å¼€å§‹å¤„ç†ï¼š{file_path} ï¼ˆå…± {len(df)} è¡Œï¼‰")

    for idx, row in df.iterrows():
        text, voice_id, row_id = extract_fields(row, df)
        if pd.isna(text) or pd.isna(voice_id) or pd.isna(row_id):
            print(f"âš ï¸ ç¬¬ {idx+1} è¡Œç¼ºå¤±å¿…è¦å­—æ®µï¼Œå·²è·³è¿‡")
            continue

        mp3_name = f"{filename}_{safe_filename(row_id)}.mp3"
        full_output = os.path.join(file_output_dir, mp3_name)

        generate_speech(text, voice_id, full_output)
        time.sleep(1)

# ===== ä¸»ç¨‹åºå…¥å£ =====
if __name__ == "__main__":
    root = Tk()
    root.withdraw()

    messagebox.showinfo("æ“ä½œæç¤º 1/2", "è¯·é€‰æ‹©è¦å¤„ç†çš„è¡¨æ ¼æ–‡ä»¶ï¼ˆå¯å¤šé€‰ï¼‰ï¼šCSV / XLS / XLSX")
    file_paths = filedialog.askopenfilenames(
        title="ğŸ“‚ è¯·é€‰æ‹©éœ€è¦å¤„ç†çš„æ–‡ä»¶ï¼ˆå¯å¤šé€‰ï¼‰",
        filetypes=[("è¡¨æ ¼æ–‡ä»¶", "*.csv *.xls *.xlsx"), ("CSV", "*.csv"), ("Excel", "*.xls *.xlsx")]
    )
    if not file_paths:
        print("âŒ æœªé€‰æ‹©ä»»ä½•æ–‡ä»¶ï¼Œç¨‹åºé€€å‡ºã€‚")
        exit()

    messagebox.showinfo("æ“ä½œæç¤º 2/2", "è¯·é€‰æ‹©ä¿å­˜è¯­éŸ³æ–‡ä»¶çš„æ–‡ä»¶å¤¹ï¼ˆç¨‹åºä¼šä¸ºæ¯ä¸ªæ–‡ä»¶è‡ªåŠ¨å»ºç«‹å­æ–‡ä»¶å¤¹ï¼‰")
    base_output_dir = filedialog.askdirectory(title="ğŸ“ è¯·é€‰æ‹©ä¿å­˜è¯­éŸ³æ–‡ä»¶çš„æ–‡ä»¶å¤¹")
    if not base_output_dir:
        print("âŒ æœªé€‰æ‹©è¾“å‡ºæ–‡ä»¶å¤¹ï¼Œç¨‹åºé€€å‡ºã€‚")
        exit()

    print(f"\nğŸš€ å¼€å§‹æ‰¹é‡å¤„ç†ï¼Œè¾“å‡ºç›®å½•ï¼š{base_output_dir}")
    for file in file_paths:
        process_file(file, base_output_dir)

    print("\nğŸ‰ å…¨éƒ¨å®Œæˆï¼")
