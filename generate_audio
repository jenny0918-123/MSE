import os
import time
import requests
import pandas as pd
import re
import unicodedata
import string
from tkinter import Tk, filedialog, messagebox

# ===== API Key 配置（写死在代码里）=====
API_KEY = "sk_255df5eece0e6606be8a93541da4e54f40decfd7abc0997f"  # ← 这里换成你的真实 Key
HEADERS = {
    "accept": "*/*",
    "xi-api-key": API_KEY,
    "Content-Type": "application/json"
}

MODEL_ID = "eleven_monolingual_v1"
VOICE_SETTINGS = {"stability": 0.5, "similarity_boost": 0.75}

# ===== 清洗函数 =====
def clean_text(text: str) -> str:
    text = re.sub(r"[\x00-\x1f\x7f-\x9f]", "", str(text))
    text = ''.join(c for c in text if c <= '\uFFFF')
    return text.strip()

def voice_id_cleaner(raw_id: str) -> str:
    raw_id = unicodedata.normalize("NFKC", str(raw_id))
    return ''.join(c for c in raw_id if c in string.ascii_letters + string.digits + "-_").strip()

def safe_filename(name: str) -> str:
    name = unicodedata.normalize("NFKD", str(name))
    out = ''.join(c for c in name if c in string.ascii_letters + string.digits + "_-")
    return out.strip() or "untitled"

# ===== 自动读取文件内容 =====
def read_table_auto(file_path: str) -> pd.DataFrame | None:
    try:
        if file_path.endswith(".csv"):
            try:
                return pd.read_csv(file_path, encoding="utf-8", dtype=str)
            except UnicodeDecodeError:
                return pd.read_csv(file_path, encoding="gbk", dtype=str)
        elif file_path.endswith((".xls", ".xlsx")):
            return pd.read_excel(file_path, dtype=str)
        else:
            return None
    except Exception as e:
        print(f"❌ 无法读取 {file_path}，错误: {e}")
        return None

# ===== 从一行中抽取字段（自适配列名或列位）=====
def extract_fields(row: pd.Series, df: pd.DataFrame):
    def find_col(candidates):
        colmap = {str(c).strip().lower(): c for c in df.columns}
        for cand in candidates:
            key = cand.strip().lower()
            if key in colmap:
                return colmap[key]
        return None

    text_col = find_col(["text", "content", "文本", "台词", "朗读文本"])
    voice_col = find_col(["voice_id", "voice", "音色", "声音", "语音id"])
    id_col = find_col(["id", "row_id", "编号", "序号"])

    text = (row[text_col] if text_col else (row.iloc[2] if len(row) > 2 else None))
    voice_id = (row[voice_col] if voice_col else (row.iloc[3] if len(row) > 3 else None))
    row_id = (row[id_col] if id_col else (row.iloc[1] if len(row) > 1 else None))
    return text, voice_id, row_id

# ===== 调用 ElevenLabs API 合成语音 =====
def generate_speech(text: str, voice_id: str, output_path: str):
    text = clean_text(text)
    voice_id = voice_id_cleaner(voice_id)
    api_url = f"https://api.elevenlabs.io/v1/text-to-speech/{voice_id}/stream"

    data = {"text": text, "model_id": MODEL_ID, "voice_settings": VOICE_SETTINGS}

    try:
        resp = requests.post(api_url, headers=HEADERS, json=data, timeout=60)
        if resp.status_code == 200 and resp.content:
            with open(output_path, "wb") as f:
                f.write(resp.content)
            print(f"✅ 成功生成: {output_path}")
            return True
        else:
            print(f"❌ API失败: {resp.status_code} - {resp.text[:200]}")
    except Exception as e:
        print(f"❌ 请求异常: {e}")
    return False

# ===== 处理单个文件 =====
def process_file(file_path: str, base_output_dir: str):
    filename_raw = os.path.splitext(os.path.basename(file_path))[0]
    filename = safe_filename(filename_raw)
    df = read_table_auto(file_path)

    if df is None or df.empty:
        print(f"⚠️ 文件 {file_path} 无内容，跳过")
        return

    file_output_dir = os.path.join(base_output_dir, filename)
    os.makedirs(file_output_dir, exist_ok=True)

    print(f"▶️ 开始处理：{file_path} （共 {len(df)} 行）")

    for idx, row in df.iterrows():
        text, voice_id, row_id = extract_fields(row, df)
        if pd.isna(text) or pd.isna(voice_id) or pd.isna(row_id):
            print(f"⚠️ 第 {idx+1} 行缺失必要字段，已跳过")
            continue

        mp3_name = f"{filename}_{safe_filename(row_id)}.mp3"
        full_output = os.path.join(file_output_dir, mp3_name)

        generate_speech(text, voice_id, full_output)
        time.sleep(1)

# ===== 主程序入口 =====
if __name__ == "__main__":
    root = Tk()
    root.withdraw()

    messagebox.showinfo("操作提示 1/2", "请选择要处理的表格文件（可多选）：CSV / XLS / XLSX")
    file_paths = filedialog.askopenfilenames(
        title="📂 请选择需要处理的文件（可多选）",
        filetypes=[("表格文件", "*.csv *.xls *.xlsx"), ("CSV", "*.csv"), ("Excel", "*.xls *.xlsx")]
    )
    if not file_paths:
        print("❌ 未选择任何文件，程序退出。")
        exit()

    messagebox.showinfo("操作提示 2/2", "请选择保存语音文件的文件夹（程序会为每个文件自动建立子文件夹）")
    base_output_dir = filedialog.askdirectory(title="📁 请选择保存语音文件的文件夹")
    if not base_output_dir:
        print("❌ 未选择输出文件夹，程序退出。")
        exit()

    print(f"\n🚀 开始批量处理，输出目录：{base_output_dir}")
    for file in file_paths:
        process_file(file, base_output_dir)

    print("\n🎉 全部完成！")
